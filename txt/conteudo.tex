% \chapter{Introdução aos Protocolos Web}
% \section{Protocolo de Transferência de Hipertexto (HTTP)}

% \subsubsection{Requisições e Respostas}
% \subsubsection{Estrutura das Requisições HTTP}
% \subsubsection{Estrutura das Respostas HTTP}
% \subsubsection{Cabeçalhos}
% \subsubsection{Métodos HTTP}
% \subsubsection{Códigos de Status}
% \subsubsection{Tipos MIME}
% \subsubsection{Cookies}
% \subsubsection{Executando HTTP na Linha de Comando}
% \begin{itemize}
% \item Usando cURL e outras ferramentas
% \end{itemize}


% \section{Comunicação Bidirecional}
% \subsubsection{Polling e Long Polling}
% \subsubsection{Server-Sent Events}
% \subsubsection{WebSockets}
% \begin{itemize}
% \item Introdução ao WebSockets
% \item Implementando WebSockets no Node.js
% \end{itemize}


\chapter{A Web}

\section{História da Web}

A história da Web é uma jornada fascinante que começou no final da década de 1980 e se desenvolveu rapidamente, transformando a maneira como interagimos com a informação e o mundo ao nosso redor.

% \subsection{As Origens da Web}
A World Wide Web foi inventada por Tim Berners-Lee, um cientista britânico do CERN (Organização Europeia para a Pesquisa Nuclear), em 1989. Berners-Lee desenvolveu a Web como uma solução para compartilhar documentos entre os pesquisadores do CERN. Ele propôs um sistema de gerenciamento de informações que conectaria documentos utilizando hiperlinks, permitindo que os usuários navegassem facilmente de um documento para outro .

Em 1990, Berners-Lee, juntamente com o engenheiro de sistemas Robert Cailliau, desenvolveu os primeiros componentes essenciais da Web:
\begin{itemize}
    \item \textbf{HTML (HyperText Markup Language):} A linguagem de marcação usada para criar documentos na Web.
    \item \textbf{HTTP (Hypertext Transfer Protocol):} O protocolo usado para a transferência de documentos pela Web.
    \item \textbf{URL (Uniform Resource Locator):} O sistema de endereçamento que permite identificar e acessar documentos na Web.
\end{itemize}

No final de 1990, Tim Berners-Lee tinha o primeiro servidor Web e navegador instalado e funcionando no CERN, demonstrando suas ideias. Ele desenvolveu o código para seu servidor Web em um computador NeXT. Para evitar que fosse desligado acidentalmente, o computador trazia uma etiqueta escrita à mão em tinta vermelha: "This machine is a server. DO NOT POWER IT DOWN!!"

O endereço do servidor web era \textit{info.cern.ch} \url{http://info.cern.ch/}, foi lançado em 1990 no CERN, e a primeira página web (ainda ativa em \url{http://info.cern.ch/hypertext/WWW/TheProject.html}) explicou o que era a World Wide Web e como utilizá-la.

% \subsection{A Popularização da Web}
A Web começou a se popularizar em 1993, com o lançamento do navegador Mosaic, desenvolvido por Marc Andreessen e Eric Bina no National Center for Supercomputing Applications (NCSA). O Mosaic foi o primeiro navegador a suportar gráficos embutidos, além de texto, em uma interface amigável. Isso marcou o início da explosão da Web como uma ferramenta acessível para o público em geral.

Em 1994, Berners-Lee fundou o World Wide Web Consortium (W3C)~\footnote{ O World Wide Web Consortium (W3C) desenvolve padrões e diretrizes para ajudar todos a construir uma web baseada nos princípios de acessibilidade, internacionalização, privacidade e segurança. - \url{https://www.w3.org/}} no MIT, com o objetivo de desenvolver padrões abertos que garantissem o crescimento contínuo da Web de maneira estável e interoperável. O W3C continua a ser a principal organização de padrões para a Web até hoje .

% \subsection{Evolução e Impacto da Web}
Desde o seu início, a Web passou por várias evoluções importantes. A transição de uma Web estática, onde as páginas eram basicamente documentos de leitura, para uma Web dinâmica e interativa, onde aplicações complexas podem ser executadas diretamente no navegador, foi um marco significativo. Tecnologias como JavaScript, CSS e AJAX contribuíram para essa evolução.

A Web também teve um impacto profundo na sociedade, revolucionando a comunicação, o comércio, a educação, o entretenimento e praticamente todos os aspectos da vida moderna. Com o surgimento da Web 2.0, a interação social online tornou-se predominante, dando origem a plataformas como redes sociais, blogs e wikis.

Hoje, a Web continua a evoluir, com tendências emergentes como a Web Semântica, a Web3 e a integração de tecnologias de Inteligência Artificial, prometendo transformar ainda mais a maneira como vivemos e trabalhamos.

Para mais informações sobre a história da web, acesse ~\cite{cern_history_web}.


% \begin{tcolorbox}[colback=gray!10, colframe=gray!80, title=Internet x Web]
% É comum que os termos "Internet" e "Web" sejam usados como sinônimos, mas eles referem-se a conceitos diferentes. A Internet é uma infraestrutura global de redes interconectadas que permite a comunicação entre computadores ao redor do mundo. Ela é composta por cabos, roteadores, servidores e protocolos que facilitam o tráfego de dados entre dispositivos. Por outro lado, a Web, ou World Wide Web, é a especificação de um conjunto de tecnologias que opera sobre a Internet, utilizando o protocolo HTTP para acessar e interagir com documentos e recursos disponíveis em servidores ao redor do mundo. A Web é apenas uma das muitas aplicações que utilizam a Internet, ao lado de outras como e-mail, FTP e VoIP. Em resumo, a Internet é a rede que conecta os computadores, enquanto a Web é uma maneira de acessar e compartilhar informações através dessa rede.
% \end{tcolorbox}

\begin{question}
    Qual é a diferença entre Internet e Web?
\end{question}

\begin{solution}
    É comum que os termos "Internet" e "Web" sejam usados como sinônimos, mas eles referem-se a conceitos diferentes. A Internet é uma infraestrutura global de redes interconectadas que permite a comunicação entre computadores ao redor do mundo. Ela é composta por cabos, roteadores, servidores e protocolos que facilitam o tráfego de dados entre dispositivos. Por outro lado, a Web, ou World Wide Web, é a especificação de um conjunto de tecnologias que opera sobre a Internet, utilizando o protocolo HTTP para acessar e interagir com documentos e recursos disponíveis em servidores ao redor do mundo. A Web é apenas uma das muitas aplicações que utilizam a Internet, ao lado de outras como e-mail, FTP e VoIP. Em resumo, a Internet é a rede que conecta os computadores, enquanto a Web é uma maneira de acessar e compartilhar informações através dessa rede.
\end{solution}




\section{Protocolo de Transferência de Hipertexto (HTTP)}

\subsection{Requisições e Respostas}
O Protocolo de Transferência de Hipertexto (HTTP) é a base da comunicação na web. Em essência, o HTTP funciona no modelo de requisição-resposta, onde um cliente (geralmente um navegador) faz uma requisição a um servidor, e o servidor responde com os dados solicitados.

O cliente envia uma requisição HTTP que consiste em uma linha de requisição, cabeçalhos e um corpo opcional. O servidor responde com uma resposta HTTP, que também contém uma linha de status, cabeçalhos e um corpo opcional.

% Sugestão de Figura: Uma figura mostrando o fluxo de uma requisição HTTP e a respectiva resposta.

\subsection{Estrutura das Requisições HTTP}
Uma requisição HTTP possui a seguinte estrutura básica:

\begin{itemize}
    \item \textbf{Linha de Requisição:} Contém o método HTTP, o caminho da URL, e a versão do protocolo HTTP.
    \item \textbf{Cabeçalhos:} Metadados que fornecem informações adicionais sobre a requisição. Exemplo: `Host`, `User-Agent`, `Accept`.
    \item \textbf{Corpo (opcional):} Contém os dados enviados com a requisição, como dados de formulários em uma requisição POST.
\end{itemize}

\begin{verbatim}
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

\end{verbatim}

\subsection{Estrutura das Respostas HTTP}
A resposta HTTP segue uma estrutura similar:

\begin{itemize}
    \item \textbf{Linha de Status:} Inclui a versão do protocolo, um código de status, e uma frase descritiva.
    \item \textbf{Cabeçalhos:} Informações sobre o servidor e os dados que estão sendo enviados. Exemplo: `Content-Type`, `Content-Length`, `Set-Cookie`.
    \item \textbf{Corpo (opcional):} Contém o conteúdo real da resposta, como uma página HTML.
\end{itemize}

\begin{verbatim}
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
  <body>...</body>
</html>
\end{verbatim}

\subsection{Cabeçalhos}
Os cabeçalhos HTTP são essenciais para o controle de requisições e respostas. Eles podem ser divididos em quatro categorias principais:

\begin{itemize}
    \item \textbf{Cabeçalhos Gerais:} Aplicam-se tanto a requisições quanto a respostas, como `Cache-Control` e `Date`.
    \item \textbf{Cabeçalhos de Requisição:} Específicos para requisições, como `Accept`, `User-Agent`, e `Host`.
    \item \textbf{Cabeçalhos de Resposta:} Específicos para respostas, como `Content-Type`, `Server`, e `Set-Cookie`.
    \item \textbf{Cabeçalhos de Entidade:} Relacionam-se ao corpo da mensagem, como `Content-Length` e `Content-Encoding`.
\end{itemize}

% Sugestão de Tabela: Tabela listando alguns cabeçalhos comuns e suas funções.

\subsection{Métodos HTTP}
Os métodos HTTP definem a ação a ser realizada na requisição. Os métodos mais comuns são:

\begin{itemize}
    \item \textbf{GET:} Solicita a representação de um recurso específico. Não deve alterar o estado do servidor.
    \item \textbf{POST:} Envia dados para o servidor para criar ou modificar um recurso.
    \item \textbf{PUT:} Substitui o recurso no servidor pela carga útil da requisição.
    \item \textbf{DELETE:} Remove um recurso específico do servidor.
    \item \textbf{HEAD:} Solicita uma resposta idêntica a GET, mas sem o corpo de resposta.
    \item \textbf{PATCH:} Aplica modificações parciais a um recurso.
\end{itemize}

\subsection{Códigos de Status}
Os códigos de status HTTP informam o resultado da requisição. Eles são divididos em cinco classes:

\begin{itemize}
    \item \textbf{1xx (Informativo):} Indica que a requisição foi recebida e está em processamento.
    \item \textbf{2xx (Sucesso):} Indica que a requisição foi bem-sucedida. Exemplo: 200 OK.
    \item \textbf{3xx (Redirecionamento):} Indica que o cliente precisa tomar uma ação adicional para completar a requisição. Exemplo: 301 Moved Permanently.
    \item \textbf{4xx (Erro do Cliente):} Indica que houve um erro na requisição. Exemplo: 404 Not Found.
    \item \textbf{5xx (Erro do Servidor):} Indica que o servidor encontrou um erro ao processar a requisição. Exemplo: 500 Internal Server Error.
\end{itemize}

\subsection{Tipos MIME}
O tipo MIME (Multipurpose Internet Mail Extensions) define o tipo de conteúdo da resposta HTTP. Os tipos MIME comuns incluem:

\begin{itemize}
    \item \textbf{text/html:} Para documentos HTML.
    \item \textbf{application/json:} Para dados no formato JSON.
    \item \textbf{image/png:} Para imagens no formato PNG.
    \item \textbf{application/xml:} Para dados no formato XML.
\end{itemize}

% Sugestão de Tabela: Tabela com exemplos de tipos MIME comuns e suas descrições.

\subsection{Cookies}
Cookies são pequenos pedaços de dados armazenados no cliente pelo servidor. Eles são usados para manter o estado entre requisições HTTP, que são inerentemente sem estado. Cookies podem armazenar informações como identificadores de sessão, preferências do usuário, e outros dados de rastreamento.

Os cookies são definidos no cabeçalho `Set-Cookie` da resposta HTTP e são enviados de volta ao servidor em requisições subsequentes.

% Sugestão de Figura: Diagrama ilustrando o fluxo de cookies entre o cliente e o servidor.

\subsection{Executando HTTP na Linha de Comando}
Ferramentas como cURL permitem que desenvolvedores façam requisições HTTP diretamente da linha de comando. Isso é útil para testar APIs e depurar problemas de rede.

\begin{verbatim}
# Exemplo de requisição GET com cURL
curl -X GET https://api.example.com/data

# Exemplo de requisição POST com cURL
curl -X POST https://api.example.com/data -d '{"key":"value"}' -H "Content-Type: application/json"
\end{verbatim}

% Comentário: Incluir mais exemplos práticos de cURL ou outras ferramentas como HTTPie pode ser útil para os alunos.


\section{A linguagem de marcação de hyper-texto (HTML)}

A \textbf{Linguagem de Marcação de Hyper-Texto (HTML)} é a espinha dorsal da Web, sendo a principal linguagem utilizada para criar e estruturar conteúdo na Internet. HTML é uma linguagem de marcação, o que significa que ela usa uma série de \textit{tags} ou marcas para definir elementos dentro de um documento. Esses elementos podem incluir textos, imagens, links, tabelas, formulários, e muito mais.

\subsection{Estrutura Básica de um Documento HTML}

Todo documento HTML possui uma estrutura básica que deve ser seguida. A estrutura de um arquivo HTML típico é composta por:

\begin{verbatim}
<!DOCTYPE html>
<html>
  <head>
    <title>Título da Página</title>
  </head>
  <body>
    <h1>Bem-vindo à Web</h1>
    <p>Este é um exemplo de documento HTML.</p>
  </body>
</html>
\end{verbatim}

\begin{itemize}
    \item \textbf{DOCTYPE:} Declara o tipo do documento e a versão do HTML que está sendo utilizada. O mais comum atualmente é o \texttt{<!DOCTYPE html>} que indica HTML5.
    \item \textbf{<html>:} A tag \texttt{<html>} encapsula todo o conteúdo do documento HTML.
    \item \textbf{<head>:} A tag \texttt{<head>} contém metadados sobre o documento, como o título que aparece na aba do navegador, links para folhas de estilo, scripts, e outras informações.
    \item \textbf{<body>:} A tag \texttt{<body>} contém todo o conteúdo visível para o usuário, como textos, imagens, links, e outros elementos de interface.
\end{itemize}

\subsection{Elementos HTML}
Os elementos HTML são representados por tags, que geralmente vêm em pares: uma tag de abertura e uma tag de fechamento. As tags de abertura e fechamento delimitam o início e o fim de um elemento.

\begin{itemize}
    \item \textbf{Tags de Cabeçalho:} Usadas para criar títulos e subtítulos na página (\texttt{<h1>} a \texttt{<h6>}).
    \item \textbf{Tags de Parágrafo:} Usadas para definir parágrafos de texto (\texttt{<p>}).
    \item \textbf{Tags de Link:} Usadas para criar hiperlinks para outros documentos ou seções (\texttt{<a href="...">}).
    \item \textbf{Tags de Imagem:} Usadas para incluir imagens no documento (\texttt{<img src="...">}).
    \item \textbf{Tags de Lista:} Usadas para criar listas ordenadas (\texttt{<ol>}) ou não ordenadas (\texttt{<ul>}).
\end{itemize}

\subsection{A Evolução do HTML}

O HTML evoluiu significativamente desde sua criação. As primeiras versões do HTML focavam em estruturação básica de conteúdo, mas versões posteriores, como o HTML5, introduziram novos elementos semânticos, como \texttt{<article>}, \texttt{<section>}, e \texttt{<nav>}, além de suporte nativo para multimídia e APIs avançadas para desenvolvimento web.

O HTML5, em particular, tornou-se o padrão mais amplamente adotado, sendo projetado para ser compatível com dispositivos modernos e suportando uma gama mais ampla de funcionalidades, como vídeos embutidos, gráficos, e aplicativos interativos.

\section{O sistema de endereçamento (URL)}

A \textbf{Uniform Resource Locator (URL)}, ou Localizador Uniforme de Recursos, é um sistema de endereçamento utilizado na Web para identificar e localizar recursos disponíveis na Internet. Cada URL aponta para um recurso específico, que pode ser uma página HTML, um documento PDF, uma imagem, ou qualquer outro tipo de conteúdo acessível na Web.

\subsection{Estrutura de uma URL}
Uma URL é composta por várias partes distintas que indicam diferentes aspectos do recurso a ser acessado. A estrutura geral de uma URL é a seguinte:

\scriptsize
\begin{verbatim}
http://www.exemplo.com:80/caminho/para/recurso?query=parametro#ancora
\end{verbatim}
\normalsize

Vamos decompor essa URL em suas partes componentes:

\begin{itemize}
    \item \textbf{Protocolo:} \texttt{http://} ou \texttt{https://} especifica o protocolo de comunicação a ser utilizado. O protocolo HTTPS é uma versão segura do HTTP.
    \item \textbf{Nome de Domínio:} \texttt{www.exemplo.com} identifica o servidor onde o recurso está hospedado. Este nome de domínio pode ser traduzido em um endereço IP pelo DNS (Domain Name System).
    \item \textbf{Porta:} \texttt{:80} é a porta de comunicação do servidor utilizada pelo protocolo. A porta 80 é o padrão para HTTP, enquanto a porta 443 é padrão para HTTPS.
    \item \textbf{Caminho:} \texttt{/caminho/para/recurso} indica o caminho no servidor para o recurso específico. Pode referenciar diretórios ou arquivos.
    \item \textbf{Query String:} \texttt{?query=parametro} é uma cadeia de caracteres que fornece parâmetros adicionais para a requisição, frequentemente utilizados para busca ou filtragem de dados.
    \item \textbf{Fragmento:} \texttt{\#ancora} refere-se a uma parte específica do recurso, como uma âncora em uma página HTML que leva a um local específico dentro do documento.
\end{itemize}

\subsection{Funcionalidade das URLs}

URLs desempenham um papel crucial na navegação na Web. Elas não apenas indicam ao navegador onde encontrar um recurso, mas também como acessar e interagir com ele. Por exemplo, uma URL pode incluir parâmetros que modificam a forma como o conteúdo é apresentado ou como uma pesquisa é realizada em um site.

\subsection{URLs e SEO}

As URLs também são um elemento importante na otimização para motores de busca (SEO). URLs claras, descritivas e bem estruturadas podem melhorar a indexação de uma página pelos motores de busca e aumentar a visibilidade do site.

\subsection{Segurança e URLs}

Com o crescimento da Web, a segurança das URLs tornou-se uma preocupação central. HTTPS, por exemplo, foi introduzido para proteger as comunicações entre o navegador e o servidor, criptografando os dados para evitar interceptações maliciosas.

% Comentário: Considerar a inclusão de exemplos práticos que mostrem como diferentes tipos de URLs são construídos e utilizados em aplicações web.




\section{Comunicação Bidirecional}
\subsection{Polling e Long Polling}
Polling e Long Polling são técnicas usadas para manter uma comunicação bidirecional entre o cliente e o servidor, especialmente em aplicações que necessitam de atualizações frequentes.

\begin{itemize}
    \item \textbf{Polling:} O cliente faz requisições periódicas ao servidor para verificar se há novas informações. Essa técnica pode ser ineficiente devido à quantidade de requisições feitas.
    \item \textbf{Long Polling:} O servidor mantém a conexão aberta até que haja novas informações para enviar ao cliente, reduzindo o número de requisições.
\end{itemize}

\subsection{Server-Sent Events}
Server-Sent Events (SSE) permitem que um servidor envie dados de atualização para o cliente de forma contínua, usando uma conexão HTTP única. Isso é útil para notificações em tempo real, feeds de dados e outras aplicações que necessitam de atualizações contínuas.

\begin{verbatim}
# Exemplo de código SSE no lado do servidor (Node.js)
const express = require('express');
const app = express();

app.get('/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    setInterval(() => {
        res.write(`data: ${new Date().toISOString()}\n\n`);
    }, 1000);
});

app.listen(3000, () => console.log('SSE server running on port 3000'));
\end{verbatim}

\subsection{WebSockets}
\textbf{Introdução ao WebSockets}

WebSockets fornecem uma comunicação bidirecional em tempo real entre o cliente e o servidor sobre uma única conexão TCP. Diferente do HTTP, o WebSocket permite que tanto o cliente quanto o servidor enviem dados a qualquer momento, sem a necessidade de repetidas requisições HTTP.

\textbf{Implementando WebSockets no Node.js}

Para implementar WebSockets em Node.js, a biblioteca \texttt{ws} é uma escolha popular. A seguir, um exemplo básico de implementação:

\begin{verbatim}
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', ws => {
    ws.on('message', message => {
        console.log(`Received message => ${message}`);
    });
    ws.send('Hello! You are connected.');
});
\end{verbatim}

Este exemplo cria um servidor WebSocket que ouve na porta 8080. Quando um cliente se conecta, o servidor pode enviar e receber mensagens em tempo real.

% Comentário: Considere incluir uma explicação sobre como usar ferramentas como o "WebSocket Tester" ou extensões de navegador para testar WebSockets.















% =================================================================================
% \chapter{Usando APIs Web}
% \section{Alterando Páginas Web Dinamicamente Usando a API DOM}
% \begin{itemize}
%     \item O Modelo de Objeto de Documento (DOM)
%     \item Os Diferentes Tipos de Nós
%     \item Selecionando Elementos
%     \item Modificando Elementos
%     \item Criando, Adicionando e Excluindo Elementos
%     \item Exemplo Prático: Criação Dinâmica de uma Tabela
% \end{itemize}
% \section{Carregando Dados Sincronamente via Ajax e a API Fetch}
% \begin{itemize}
%     \item Comunicação Sincrona versus Assíncrona
%     \item Carregando Dados via Ajax
% \end{itemize}
% \subsection{Carregando Dados via a API Fetch}
% \begin{itemize}
%     \item Visão Geral das APIs Web
%     \item Suporte dos Navegadores para APIs Web
% \end{itemize}



\chapter{Usando APIs Web}

\section{Alterando Páginas Web Dinamicamente Usando a API DOM}

\subsection{O Modelo de Objeto de Documento (DOM)}
O Modelo de Objeto de Documento, ou DOM (\textit{Document Object Model}), é uma interface de programação que permite a manipulação de documentos HTML e XML como uma estrutura de árvore, onde cada nó representa uma parte do documento, como elementos, atributos ou texto. O DOM é essencial para a criação de páginas web dinâmicas, permitindo que os desenvolvedores interajam e modifiquem a estrutura e o conteúdo das páginas em tempo real.

% Sugestão de Figura: Uma ilustração mostrando a estrutura em árvore do DOM, com elementos HTML como nós.

\subsection{Os Diferentes Tipos de Nós}
No DOM, existem vários tipos de nós, cada um representando uma parte específica do documento:

\begin{itemize}
    \item \textbf{Nós de Elemento:} Representam tags HTML, como \texttt{<div>}, \texttt{<p>}, \texttt{<a>}.
    \item \textbf{Nós de Atributo:} Representam os atributos de um elemento HTML, como \texttt{id}, \texttt{class}.
    \item \textbf{Nós de Texto:} Representam o conteúdo textual dentro de um elemento HTML.
    \item \textbf{Nós de Comentário:} Representam os comentários no código HTML.
    \item \textbf{Nós de Documento:} Representam o próprio documento inteiro, como a raiz da árvore DOM.
\end{itemize}

% Sugestão de Código: Exemplo de como acessar diferentes tipos de nós no DOM usando JavaScript.

\begin{verbatim}
// Acessando um nó de elemento
let elementNode = document.getElementById('myElement');

// Acessando um nó de atributo
let attributeNode = elementNode.getAttributeNode('class');

// Acessando um nó de texto
let textNode = elementNode.firstChild;
\end{verbatim}

\subsection{Selecionando Elementos}
Para modificar uma página web dinamicamente, primeiro precisamos selecionar os elementos que desejamos alterar. O DOM fornece várias maneiras de selecionar elementos:

\begin{itemize}
    \item \textbf{getElementById}: Seleciona um único elemento pelo seu \texttt{id}.
    \item \textbf{getElementsByClassName}: Seleciona todos os elementos que possuem uma determinada classe.
    \item \textbf{getElementsByTagName}: Seleciona todos os elementos com uma determinada tag.
    \item \textbf{querySelector}: Seleciona o primeiro elemento que corresponde a um seletor CSS.
    \item \textbf{querySelectorAll}: Seleciona todos os elementos que correspondem a um seletor CSS.
\end{itemize}

\begin{verbatim}
// Exemplo de seleção de elementos
let element = document.getElementById('header');
let elements = document.querySelectorAll('.item');
\end{verbatim}

\subsection{Modificando Elementos}
Depois de selecionar um elemento, podemos modificar suas propriedades, conteúdo, ou estilo diretamente através do DOM.

\begin{itemize}
    \item \textbf{Modificando o Conteúdo:} Use \texttt{innerHTML} ou \texttt{textContent} para alterar o conteúdo interno de um elemento.
    \item \textbf{Alterando Estilos:} Modifique o estilo de um elemento através da propriedade \texttt{style}.
    \item \textbf{Adicionando/Removendo Classes:} Use \texttt{classList} para adicionar, remover ou alternar classes de um elemento.
\end{itemize}

\begin{verbatim}
// Exemplo de modificação de conteúdo e estilo
let element = document.getElementById('header');
element.textContent = 'Novo Título';
element.style.color = 'blue';
element.classList.add('novo-estilo');
\end{verbatim}

\subsection{Criando, Adicionando e Excluindo Elementos}
O DOM permite que você crie novos elementos, adicione-os ao documento e remova elementos existentes.

\begin{itemize}
    \item \textbf{Criando Elementos:} Use \texttt{document.createElement()} para criar um novo elemento.
    \item \textbf{Adicionando Elementos:} Use \texttt{appendChild()} ou \texttt{insertBefore()} para adicionar o novo elemento à árvore DOM.
    \item \textbf{Excluindo Elementos:} Use \texttt{removeChild()} ou \texttt{element.remove()} para remover um elemento.
\end{itemize}

\begin{verbatim}
// Exemplo de criação e adição de um novo elemento
let newElement = document.createElement('p');
newElement.textContent = 'Este é um novo parágrafo.';
document.body.appendChild(newElement);

// Exemplo de remoção de um elemento
let elementToRemove = document.getElementById('oldElement');
elementToRemove.remove();
\end{verbatim}

\subsection{Exemplo Prático: Criação Dinâmica de uma Tabela}
Vamos criar dinamicamente uma tabela HTML utilizando JavaScript e a API DOM. Este exemplo prático ajudará a solidificar os conceitos discutidos.

\begin{verbatim}
// Criando a tabela e os elementos associados
let table = document.createElement('table');
let headerRow = document.createElement('tr');
let headers = ['Nome', 'Idade', 'Profissão'];

headers.forEach(headerText => {
    let header = document.createElement('th');
    header.textContent = headerText;
    headerRow.appendChild(header);
});

table.appendChild(headerRow);

// Adicionando linhas de dados à tabela
let data = [
    ['Alice', 30, 'Engenheira de Software'],
    ['Bob', 25, 'Designer'],
    ['Carol', 28, 'Gerente de Projetos']
];

data.forEach(rowData => {
    let row = document.createElement('tr');
    rowData.forEach(cellData => {
        let cell = document.createElement('td');
        cell.textContent = cellData;
        row.appendChild(cell);
    });
    table.appendChild(row);
});

// Adicionando a tabela ao corpo do documento
document.body.appendChild(table);
\end{verbatim}

% Sugestão de Figura: Captura de tela da tabela gerada dinamicamente no navegador.

\section{Carregando Dados Sincronamente via Ajax e a API Fetch}

\subsection{Comunicação Sincrona versus Assíncrona}
A comunicação síncrona envolve a execução de tarefas de maneira sequencial, onde uma tarefa deve ser concluída antes que a próxima comece. Em contrapartida, a comunicação assíncrona permite que as tarefas sejam iniciadas sem esperar pela conclusão das anteriores, o que é crucial para melhorar a performance e a experiência do usuário em aplicações web.

% Comentário: Explicar o impacto da comunicação síncrona em termos de bloqueio da interface do usuário e como a comunicação assíncrona mitiga esse problema.

\subsection{Carregando Dados via Ajax}
Ajax (Asynchronous JavaScript and XML) é uma técnica amplamente usada para carregar dados de forma assíncrona sem recarregar a página inteira. Ajax permite que as aplicações web se tornem mais interativas e responsivas.

\begin{verbatim}
// Exemplo básico de uma requisição Ajax usando XMLHttpRequest
let xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);

xhr.onload = function() {
    if (xhr.status === 200) {
        console.log(xhr.responseText);
    } else {
        console.error('Erro na requisição.');
    }
};

xhr.send();
\end{verbatim}

% Sugestão de Comentário: Discutir a obsolescência do Ajax em favor do Fetch API, destacando a sintaxe mais moderna e as vantagens do Fetch.

\subsection{Carregando Dados via a API Fetch}

\subsubsection{Visão Geral das APIs Web}
A API Fetch é uma API moderna e baseada em Promises para fazer requisições HTTP assíncronas. Diferente do XMLHttpRequest, Fetch proporciona uma maneira mais simples e poderosa de buscar recursos através da rede.

\begin{verbatim}
// Exemplo básico de uma requisição com a Fetch API
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('Erro na requisição');
        }
        return response.json();
    })
    .then(data => console.log(data))
    .catch(error => console.error('Erro:', error));
\end{verbatim}

\subsubsection{Suporte dos Navegadores para APIs Web}
Embora a API Fetch seja amplamente suportada pelos navegadores modernos, é importante considerar o suporte para navegadores legados ao desenvolver aplicações web. O uso de polyfills pode ser uma solução para garantir compatibilidade.

% Comentário: Incluir referências para documentação e ferramentas de verificação de suporte a navegadores, como o "Can I Use".


















% =================================================================================
\chapter{JavaScript no Lado do Servidor com Node.js}

\section{Introdução ao Node.js}
\subsubsection{Arquitetura do Node.js}
\begin{itemize}
\item Arquitetura Orientada a Eventos no Node.js
\item I/O Não Bloqueante
\end{itemize}
\subsubsection{Um Primeiro Programa}
\begin{itemize}
\item Construindo um Servidor Web Simples
\end{itemize}
\subsubsection{Gerenciamento de Pacotes com npm}
\begin{itemize}
\item Instalando e Gerenciando Pacotes
\item Criando e Publicando seu Próprio Pacote
\end{itemize}

\section{Utilizando Módulos Nativos do Node.js}
\subsubsection{Trabalhando com o Sistema de Arquivos}
\begin{itemize}
\item Lendo Arquivos
\item Escrevendo Arquivos
\item Deletando Arquivos
\end{itemize}
\subsubsection{Trabalhando com Buffers e Streams}
\subsubsection{Rede}
\begin{itemize}
\item Criando Servidores TCP e HTTP
\item Trabalhando com Sockets
\end{itemize}


\section{Construindo Servidores Web}
\subsubsection{Preparando o Ambiente de Desenvolvimento}
\subsubsection{Fornecendo Arquivos Estáticos}
\subsubsection{Usando o Framework Express.js}
\begin{itemize}
\item Configurando o Express.js
\item Roteamento no Express.js
\item Middleware no Express.js
\end{itemize}
\subsubsection{Processando Dados de Formulários}
\subsubsection{Usando Motores de Template com Express.js}
\begin{itemize}
\item Pug, Mustache, e EJS
\end{itemize}
\subsection{Extra: Formatos Web}
\begin{itemize}
    \item Formatos de dados: CSV, XML e JSON
    \item Formatos de imagem: JPG, GIF, PNG, SVG, WebP
    \item Comprando formatos de imagem
    \item Programas para processar imagens
    \item Formatos de audio e vídeo 
\end{itemize}













% =================================================================================

\chapter{Implementando Serviços Web}
\section{Introdução aos Serviços Web}

\subsubsection{Visão Geral dos Serviços Web}


\section{Serviços Web RESTful}

\subsubsection{Princípios do REST}
\subsubsection{Implementando uma API REST}
\begin{itemize}
\item Usando Express.js para Criar Endpoints RESTful
\item Manipulando Operações CRUD
\end{itemize}
\subsubsection{Consumindo uma API REST}
\begin{itemize}
\item Consumindo APIs RESTful com JavaScript
\item Tratamento de Erros e Melhores Práticas
\end{itemize}


\section{GraphQL}

\subsubsection{As Desvantagens do REST}
\subsubsection{Introdução ao GraphQL}
\subsubsection{Implementando GraphQL com Node.js}
\begin{itemize}
\item Configurando o GraphQL no Node.js
\item Escrevendo Queries e Mutations
\item GraphQL vs REST
\end{itemize}












% =================================================================================


\chapter{Armazenando Dados em Bancos de Dados}
\section{Bancos de Dados Relacionais}

\subsubsection{Entendendo Bancos de Dados Relacionais}
\subsubsection{A Linguagem SQL}
\begin{itemize}
\item Consultas SQL Básicas (SELECT, INSERT, UPDATE, DELETE)
\item Joins, Subconsultas e Transações
\end{itemize}
\subsubsection{Usando MySQL com Node.js}
\begin{itemize}
\item Configurando MySQL no Node.js
\item Realizando Operações CRUD com MySQL
\end{itemize}
\subsubsection{Mapeamento Objeto-Relacional (ORM)}
\begin{itemize}
\item Usando Sequelize com Node.js
\end{itemize}


\section{Bancos de Dados Não-Relacionais}

\subsubsection{Bancos de Dados Relacionais vs Não-Relacionais}
\subsubsection{Visão Geral dos Bancos de Dados Não-Relacionais}
\begin{itemize}
\item Bancos de Dados de Chave-Valor
\item Bancos de Dados Orientados a Documentos
\item Bancos de Dados de Grafos
\item Bancos de Dados Colunares
\end{itemize}
\subsubsection{Usando MongoDB com Node.js}
\begin{itemize}
\item Configurando MongoDB no Node.js
\item Operações CRUD com MongoDB
\item Framework de Agregação no MongoDB
\end{itemize}
\subsubsection{Comparando MySQL e MongoDB}




























% =================================================================================

\chapter{Arquiteturas Web}
\section{Arquiteturas em Camadas}

\subsubsection{Estrutura Básica das Arquiteturas em Camadas}
\subsubsection{Arquitetura Cliente-Servidor (Arquitetura de Dois Níveis)}
\subsubsection{Arquitetura de Múltiplos Níveis}
\begin{itemize}
\item Arquitetura N-Camadas
\item Vantagens e Desvantagens
\item Other Web APIs: 
\end{itemize}


\section{Arquiteturas Monolíticas e Distribuídas}

\subsubsection{Arquitetura Monolítica}
\subsubsection{Arquitetura Orientada a Serviços (SOA)}
\subsubsection{Arquitetura de Microsserviços}
\begin{itemize}
\item Comparando SOA e Microsserviços
\item Implementando Microsserviços com Node.js
\end{itemize}
\subsubsection{Arquitetura Baseada em Componentes}
\subsubsection{Arquitetura de Microfrontends}
\subsubsection{Arquitetura de Mensagens}
\begin{itemize}
\item Arquitetura Orientada a Eventos
\item Filas de Mensagens e Brokers (RabbitMQ, Kafka)
\end{itemize}
\subsubsection{Arquitetura de Serviços Web}
\begin{itemize}
\item SOAP vs REST
\item Implementando Serviços Web com Node.js
\end{itemize}


\section{Arquiteturas MV*}

\subsubsection{Model-View-Controller (MVC)}
\begin{itemize}
\item Implementando MVC com Express.js
\end{itemize}
\subsubsection{Model-View-Presenter (MVP)}
\subsubsection{Model-View-ViewModel (MVVM)}












% =================================================================================

\chapter{Padrões de Projeto}
\section{Introdução aos Padrões de Design}
\subsubsection{O que são Padrões de Design?}
\begin{itemize}
\item Importância dos Padrões de Design em Desenvolvimento de Software
\item Categorias de Padrões de Design: Criacionais, Estruturais e Comportamentais
\end{itemize}

\section{Padrões Criacionais}

\subsection{Singleton}
\subsection{Factory Method}
\subsection{Abstract Factory}
\subsection{Builder}
\subsection{Prototype}
\begin{itemize}
\item Implementando Padrões Criacionais com JavaScript/Node.js
\end{itemize}


\section{Padrões Estruturais}

\subsection{Adapter}
\subsection{Decorator}
\subsection{Facade}
\subsection{Proxy}
\subsection{Composite}
\subsection{Flyweight}
\subsection{Bridge}
\begin{itemize}
\item Implementando Padrões Estruturais com JavaScript/Node.js
\end{itemize}


\section{Padrões Comportamentais}

\subsection{Observer}
\subsection{Strategy}
\subsection{Command}
\subsection{Chain of Responsibility}
\subsection{Template Method}
\subsection{State}
\subsection{Iterator}
\subsection{Mediator}
\begin{itemize}
\item Implementando Padrões Comportamentais com JavaScript/Node.js
\end{itemize}















% =================================================================================

\chapter{Testando Aplicações Web}
\section{Introdução aos Testes}
\subsubsection{A Importância dos Testes no Desenvolvimento Web}

\section{Testes Unitários}
\subsubsection{Escrevendo Testes Unitários em JavaScript}
\begin{itemize}
\item Usando Mocha e Chai
\item Desenvolvimento Orientado por Testes (TDD)
\end{itemize}


\section{Testes de Integração}

\subsubsection{Testando APIs RESTful}
\begin{itemize}
\item Usando Supertest com Mocha
\end{itemize}


\section{Testes de Ponta a Ponta (E2E)}

\subsubsection{Automatizando Testes de Ponta a Ponta}
\begin{itemize}
\item Usando Cypress para Testes E2E
\end{itemize}













% =================================================================================

\chapter{Implantação e Hospedagem de Aplicações Web}
\section{Preparando para Implantação}

\subsubsection{Processo de Build e Release}
\subsubsection{Variáveis de Ambiente e Configurações}


\section{Implantando Aplicações}

\subsubsection{Implantando em Provedores de Nuvem}
\begin{itemize}
\item AWS, Azure e Google Cloud Platform
\end{itemize}
\subsubsection{Usando Docker para Implantação}
\begin{itemize}
\item Containerização com Docker
\item Dockerizando Aplicações Node.js
\end{itemize}
\subsubsection{Usando Pipelines CI/CD}
\begin{itemize}
\item Automatizando a Implantação com Jenkins, GitHub Actions e GitLab CI
\end{itemize}















% =================================================================================

\chapter{Segurança em Aplicações Web}
\section{Compreendendo a Segurança Web}

\subsubsection{Ameaças Comuns à Segurança}
\begin{itemize}
\item Injeção de SQL
\item Cross-Site Scripting (XSS)
\item Cross-Site Request Forgery (CSRF)
\end{itemize}


\section{Implementando Segurança no Node.js}

\subsubsection{Usando Helmet para Cabeçalhos de Segurança}
\subsubsection{Protegendo Aplicações Express}
\begin{itemize}
\item Validação e Sanitização de Entrada
\item Limitação de Taxa e Proteção contra DDoS
\end{itemize}
\subsubsection{Autenticação e Autorização}
\begin{itemize}
\item Implementando OAuth e JWT
\end{itemize}















% =================================================================================

\chapter{Otimizando a Performance de Aplicações Web}
\section{Identificando Gargalos de Performance}

\subsubsection{Ferramentas de Monitoramento e Profiling}
\begin{itemize}
\item Usando PM2 e New Relic
\end{itemize}


\section{Técnicas de Otimização de Performance}

\subsubsection{Estratégias de Cache}
\begin{itemize}
\item Usando Redis para Cache
\end{itemize}
\subsubsection{Balanceamento de Carga}
\subsubsection{Otimizando Consultas ao Banco de Dados}
\begin{itemize}
\item Indexação e Otimização de Consultas
\end{itemize}
\subsubsection{Otimização de Código}
\begin{itemize}
\item Vazamentos de Memória e Coleta de Lixo no Node.js
\item Otimização de Programação Assíncrona e do Event Loop
\end{itemize}


% \chapter{Sobre o Node.js}

% \thispagestyle{empty} 

% \begin{mdframed}[style=noteSty]

% {\center \textsc{Texto motivador} \par}

%    Este é um breve texto motivador. Espero que você esteja motivado(a)!
   
% \end{mdframed}


% \begin{itemize}

% \begin{enumerate}
%     \item ...
%     \item ;...
%     \item ...
% \end{enumerate}
 
% \end{itemize}

% % Muitos cientistas gostam de usar \LaTeX porque essa ferramenta possibilita escrever facilmente equações como a seguinte:
% % \begin{equation}
% %  \mathscr{p}+\frac{1}{2}{\rho}v^2+{\rho}gh = \text{constante}
% %  \label{eq:Bernoulli}
% % \end{equation}
% % onde $\mathscr{p}$ é a pressão, $v$ é a velocidade e $h$ é a elevação, ou seja, a “altura do tubo”. Essa equação pode ser deduzida a partir do \textit{Teorema Trabalho-Energia}. \index{Teorema Trabalho-Energia}  % entrada para o índice remissivo

% \newpage

% \chapter{Introdução ao Node.js}

% O Node.js é uma plataforma de código aberto construída sobre o motor JavaScript V8 do Google Chrome, que permite executar JavaScript no lado do servidor. Foi criado por Ryan Dahl em 2009 e desde então tem ganhado uma enorme popularidade na comunidade de desenvolvimento de software.

% \section{História}

% A história do Node.js remonta a 2009, quando Ryan Dahl apresentou pela primeira vez esta tecnologia em uma conferência. Naquela época, o desenvolvimento de aplicativos web era predominantemente baseado em tecnologias como PHP, Ruby on Rails e Java. No entanto, essas tecnologias enfrentavam desafios de escalabilidade quando se tratava de lidar com conexões simultâneas de clientes.

% Dahl percebeu que o modelo de E/S (entrada/saída) bloqueante das tecnologias existentes era um gargalo para o desempenho e a escalabilidade dos aplicativos web. Ele propôs o uso do motor JavaScript V8 do Chrome, que é conhecido por sua rápida execução de código, para criar um ambiente de servidor assíncrono e orientado a eventos.

% Assim, o Node.js nasceu com a promessa de oferecer um ambiente de execução leve e eficiente para construir aplicativos de rede escaláveis e em tempo real.

% \section{Por que é popular?}

% O Node.js ganhou popularidade por várias razões:

% \begin{enumerate}
%     \subsubsection{Arquitetura orientada a eventos e não bloqueante:} O Node.js utiliza uma arquitetura orientada a eventos que permite lidar com várias conexões de forma eficiente e escalável, sem bloquear a execução do código. Isso é particularmente útil para aplicativos que precisam lidar com um grande número de operações de E/S, como servidores web e aplicativos em tempo real.
    
%     \subsubsection{Ecossistema robusto:} O Node.js possui um vasto ecossistema de módulos e bibliotecas disponíveis através do npm, o maior repositório de pacotes de software do mundo. Isso facilita a criação de aplicativos complexos ao permitir que os desenvolvedores reutilizem código existente e incorporem funcionalidades de terceiros em seus aplicativos.
    
%     \subsubsection{JavaScript em ambos os lados:} Com o Node.js, os desenvolvedores podem usar JavaScript tanto no lado do cliente quanto no lado do servidor, o que simplifica o desenvolvimento de aplicativos web completos usando uma linguagem de programação coesa em toda a pilha tecnológica.
    
%     \subsubsection{Desempenho:} O Node.js é conhecido por seu desempenho rápido devido à execução assíncrona de código e ao motor JavaScript V8 altamente otimizado.
% \end{enumerate}

% Em resumo, o Node.js se tornou popular devido à sua capacidade de criar aplicativos de rede escaláveis e em tempo real de forma eficiente, sua vasta comunidade de desenvolvedores e seu ecossistema robusto de módulos e bibliotecas. Ele continua sendo uma escolha popular para o desenvolvimento de aplicativos web modernos e altamente performáticos. 

% Agora, vamos exemplificar com um pequeno código que demonstra a execução assíncrona no Node.js:

% \begin{minted}[
% frame=single, 
% linenos,
% firstnumber=1,
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray,
% fontsize=\footnotesize
% ]{js}
% // Exemplo de código assíncrono no Node.js
% const fs = require('fs');

% // Lê um arquivo de forma assíncrona
% fs.readFile('arquivo.txt', 'utf8', (err, data) => {
%   if (err) {
%     console.error('Erro ao ler o arquivo:', err);
%     return;
%   }
%   console.log('Conteúdo do arquivo:', data);
% });

% console.log('Operação assíncrona iniciada. 
%        Este console.log é executado antes da leitura do arquivo.');
% \end{minted}

% Neste exemplo, o código \texttt{fs.readFile()} inicia uma operação de leitura de arquivo de forma assíncrona. Enquanto o Node.js está lendo o arquivo, ele continua executando o código restante, como o \texttt{console.log()} subsequente, sem esperar a conclusão da operação de leitura do arquivo. Isso demonstra como o Node.js é capaz de lidar com operações de entrada/saída de forma não bloqueante, permitindo que outras operações continuem enquanto espera uma resposta de E/S.


% \chapter{Principais Características do Node.js}

% O Node.js é conhecido por várias características que o tornam uma escolha popular para o desenvolvimento de aplicativos de rede em tempo real. Aqui estão algumas das principais características destacadas:

% \begin{enumerate}
%     \subsubsection{Arquitetura Orientada a Eventos:}
%         \begin{itemize}
%             \item O Node.js opera com uma arquitetura orientada a eventos, onde as operações de entrada e saída são tratadas de forma assíncrona e não bloqueante.
%             \item Isso significa que em vez de esperar por uma operação de entrada/saída (como leitura de arquivos ou consultas de banco de dados) ser concluída antes de continuar, o Node.js continua a executar outras tarefas e manipula o resultado da operação quando estiver disponível.
%             \item Essa abordagem permite que o Node.js lide com um grande número de conexões simultâneas sem a necessidade de threads adicionais, o que resulta em um consumo mais eficiente de recursos.
%         \end{itemize}
        
%     \subsubsection{Não Bloqueante e Assíncrono:}
%         \begin{itemize}
%             \item O Node.js é não bloqueante e assíncrono por natureza, o que significa que as operações de E/S (entrada/saída) não bloqueiam a execução do código.
%             \item Em vez disso, o Node.js usa chamadas de retorno (callbacks), promessas ou async/await para lidar com operações assíncronas, permitindo que outras partes do código continuem executando enquanto aguardam a conclusão das operações de E/S.
%             \item Essa abordagem é fundamental para criar aplicativos escaláveis e eficientes, especialmente em cenários de rede em tempo real, onde várias solicitações podem chegar simultaneamente.
%         \end{itemize}
        
%     \subsubsection{Adequado para Aplicativos de Rede em Tempo Real:}
%         \begin{itemize}
%             \item Devido à sua natureza orientada a eventos e não bloqueante, o Node.js é particularmente adequado para desenvolver aplicativos de rede em tempo real, como aplicativos de bate-papo, jogos multiplayer online, streaming de vídeo e áudio, entre outros.
%             \item A capacidade do Node.js de lidar com um grande número de conexões simultâneas de forma eficiente e escalável o torna uma escolha popular para esses tipos de aplicativos.
%         \end{itemize}
% \end{enumerate}

% \section{Exemplo Prático}

% \begin{minted}[
% frame=single, 
% linenos,
% firstnumber=1,
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray,
% fontsize=\footnotesize
% ]{js}
% const http = require('http');

% // Cria um servidor HTTP simples
% const server = http.createServer((req, res) => {
%   // Simula uma operação de E/S assíncrona
%   setTimeout(() => {
%     res.writeHead(200, {'Content-Type': 'text/plain'});
%     res.end('Olá, mundo!\n');
%   }, 1000); // Responde após 1 segundo
% });

% // Inicia o servidor na porta 3000
% server.listen(3000, 'localhost', () => {
%   console.log('Servidor Node.js rodando em http://localhost:3000/');
% });
% \end{minted}

% Neste exemplo, criamos um servidor HTTP simples usando o módulo \texttt{http} do Node.js. O servidor responde com "Olá, mundo!" após um atraso de 1 segundo, simulando uma operação de E/S assíncrona. Isso demonstra como o Node.js pode lidar com operações assíncronas de forma eficiente, permitindo que o servidor continue a atender outras solicitações enquanto aguarda a conclusão da operação de E/S.


% \chapter{Explorando o Ecossistema Node.js}

% \section{npm (Node Package Manager)}

% O npm é o gerenciador de pacotes padrão para o ecossistema Node.js. Ele permite que os desenvolvedores instalem, compartilhem e gerenciem dependências de seus projetos de forma fácil e eficiente. Alguns pontos importantes a serem destacados sobre o npm incluem:

% \begin{itemize}
%     \subsubsection{Instalação de Pacotes:} Como instalar pacotes npm em um projeto Node.js usando o comando \mintinline{bash}{npm install}.
%     \subsubsection{Gerenciamento de Dependências:} Como adicionar, atualizar e remover dependências do projeto usando o npm.
%     \subsubsection{Arquivo \texttt{package.json}:} O papel crucial do arquivo \texttt{package.json} no gerenciamento de dependências, scripts de construção e metadados do projeto.
%     \subsubsection{Scripts npm:} A capacidade de definir e executar scripts personalizados usando o npm, como scripts de construção, execução de testes e muito mais.
% \end{itemize}

% \section{Express.js}

% Express.js é um framework web minimalista e flexível para Node.js, projetado para facilitar a construção de aplicativos web e APIs. Abordaremos os seguintes aspectos do Express.js:

% \begin{itemize}
%     \subsubsection{Configuração Básica:} Como configurar um aplicativo Express.js e definir rotas básicas.
%     \subsubsection{Middleware:} O conceito de middleware no Express.js e como usar middleware para manipular solicitações HTTP.
%     \subsubsection{Rotas:} Como definir e manipular rotas em um aplicativo Express.js para lidar com diferentes tipos de solicitações HTTP.
%     \subsubsection{Renderização de Visualizações:} Integração de mecanismos de visualização, como EJS ou Handlebars, para renderizar visualizações dinâmicas em aplicativos Express.js.
%     \subsubsection{Gestão de Erros:} Estratégias para lidar com erros e exceções em aplicativos Express.js, incluindo middleware de tratamento de erros.
% \end{itemize}

% \section{Exemplo Prático}

% Instalação do Express.js via npm

% \begin{minted}[
% frame=single, 
% linenos,
% firstnumber=1,
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray,
% fontsize=\footnotesize
% ]{shell}
% $ npm install express
% \end{minted}

% Após a instalação via NPM, você pode criar o exemplo abaixo em um projeto node e depois executar como uma aplicação Node normal.

% \begin{minted}[
% frame=single, 
% linenos,
% firstnumber=1,
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray,
% fontsize=\footnotesize
% ]{js}


% // Arquivo index.js
% const express = require('express');
% const app = express();

% // Rota principal
% app.get('/', (req, res) => {
%   res.send('Bem-vindo ao meu aplicativo Express!');
% });

% // Rota de exemplo com parâmetros
% app.get('/user/:id', (req, res) => {
%   res.send(`ID do usuário: ${req.params.id}`);
% });

% // Middleware para tratamento de erros
% app.use((err, req, res, next) => {
%   console.error(err.stack);
%   res.status(500).send('Algo deu errado!');
% });

% // Iniciar o servidor na porta 3000
% app.listen(3000, () => {
%   console.log('Servidor Express em execução na porta 3000');
% });
% \end{minted}

% Este exemplo demonstra como criar um aplicativo básico usando o Express.js, definir rotas simples e usar um middleware para lidar com erros. O npm é utilizado para instalar o Express.js e outras dependências necessárias para o projeto.
